package com.tencent.av.opengl.program;

import com.tencent.av.utils.ax;
import com.tencent.gamecenter.wadl.sdk.downloader.DownloaderConstant;
import com.tencent.qqmini.miniapp.widget.camera.CameraFilterEngine;
import qv.a;
import qv.b;
import qv.c;

/* loaded from: classes3.dex */
public class YUVTextureProgram extends TextureProgram {
    public YUVTextureProgram() {
        super("uniform mat4 uMatrix;uniform mat4 uTextureMatrix;attribute vec2 aPosition;varying vec2 vTextureCoord;varying vec2 vTextureCoordModel;void main() {vec4 pos = vec4(aPosition, 0.0, 1.0);gl_Position = uMatrix * pos;vTextureCoord  = (uTextureMatrix * (pos+vec4(0.5,0.5,0.0,0.0))).xy;  vTextureCoordModel = aPosition + vec2(0.5,0.5);}", e(), new b[]{new a("aPosition"), new c("uMatrix"), new c("uAlpha"), new c(CameraFilterEngine.TEXTURE_MATRIX_UNIFORM), new c("uTextureSampler0"), new c("uTextureSampler1"), new c("uTextureSampler2"), new c("fWidth"), new c("fHeight"), new c("colorMat"), new c("yuvFormat"), new c("uTextureSampler3"), new c("isModel"), new c("stride_x"), new c("stride_y"), new c(DownloaderConstant.KEY_RANGE), new c("distortType"), new c("distortOri"), new c("angle"), new c("uRadius")}, true);
    }

    private static String e() {
        if (ax.c()) {
            return "#ifdef GL_ES \n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec2 vTextureCoord ;varying vec2 vTextureCoordModel;uniform float uAlpha;uniform float stride_x;uniform float stride_y;uniform float range;uniform int   distortType;uniform int   distortOri;uniform int   angle;uniform int yuvFormat;uniform int isModel;uniform sampler2D uTextureSampler0;uniform sampler2D uTextureSampler1;uniform sampler2D uTextureSampler2;uniform sampler2D uTextureSampler3;uniform mat4 colorMat;uniform float fWidth;uniform float fHeight;uniform float uRadius;float sdfBoxWithRadius(in vec2 p, in vec2 b, float radius) {    vec2 d = abs(p) - b + vec2(radius);    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;}void main(){vec2 b = vec2(fWidth, fHeight);vec2 p = vTextureCoordModel * b;float result = sdfBoxWithRadius(p - b / 2.0, b / 2.0, uRadius);if (result >= 0.0 && ((p.x <= uRadius && (p.y <= uRadius || p.y >= fHeight - uRadius)) || (p.x >= fWidth - uRadius && (p.y <= uRadius || p.y >= fHeight - uRadius)) )) {    discard;}vec3 yuvData;float x1 = vTextureCoord.x;float y1 = vTextureCoord.y;vec2 distortCoord = vec2(x1,y1);bool isEmpty = false;if (range != 0.0){    float real_range;    if (angle == 1 || angle == 3) {        if (distortType == 0)        {            real_range = 4.0 * range * (x1 - 0.5) * (x1 - 0.5);        }        else        {            real_range = 4.0 * range * x1 * (1.0 - x1);        }        if ((distortOri == distortType))        {            if (y1 > 1.0 - real_range - stride_y + 2.0 * stride_y * real_range || y1 < stride_y)            {                isEmpty = true;            }            else            {                float y2 = (y1 - stride_y * real_range) / (1.0 - real_range);                distortCoord = vec2(x1,y2);            }        }        else        {            if (y1 <  real_range + stride_y - 2.0 * stride_y * real_range || y1 > 1.0 - stride_y)            {                isEmpty = true;            }            else            {                float y2 = (y1 - real_range + stride_y * real_range) / (1.0 - real_range);                distortCoord = vec2(x1,y2);            }        }     }  else {        if (distortType == 0)        {            real_range = 4.0 * range * (y1 - 0.5) * (y1 - 0.5);        }        else        {            real_range = 4.0 * range * y1 * (1.0 - y1);        }        if ((distortOri == distortType))        {            if (x1 > 1.0 - real_range - stride_x + 2.0 * stride_x * real_range || x1 < stride_x)            {                isEmpty = true;            }            else            {                float x2 = (x1 - stride_x * real_range) / (1.0 - real_range);                distortCoord = vec2(x2,y1);            }        }        else        {            if (x1 <  real_range + stride_x - 2.0 * stride_x * real_range || x1 > 1.0 - stride_x)            {                isEmpty = true;            }            else            {                float x2 = (x1 - real_range + stride_x * real_range) / (1.0 - real_range);                distortCoord = vec2(x2,y1);            }        }  }} if (isEmpty){    gl_FragColor = vec4(0,0,0,0);}else{  yuvData.x = texture2D(uTextureSampler0, distortCoord).x;    if(yuvFormat==1||yuvFormat==2){      vec2 uv = texture2D(uTextureSampler1, distortCoord).ra;      yuvData.y = uv.x;      yuvData.z = uv.y;}else if(yuvFormat==3){      vec2 uv = texture2D(uTextureSampler1, distortCoord).ra;      yuvData.z = uv.x;      yuvData.y = uv.y;}else{     yuvData.y = texture2D(uTextureSampler1, distortCoord).x;      yuvData.z = texture2D(uTextureSampler2, distortCoord).x;}  vec4 rgbData =  colorMat * vec4(yuvData,1.0);gl_FragColor = vec4 (rgbData.xyz, 1.0) * uAlpha;}if(isModel==1){        gl_FragColor.a=texture2D(uTextureSampler3, vTextureCoordModel).a;}}";
        }
        return "#ifdef GL_ES \n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec2 vTextureCoord ;varying vec2 vTextureCoordModel;uniform float uAlpha;uniform float stride_x;uniform float stride_y;uniform float range;uniform int   distortType;uniform int   distortOri;uniform int   angle;uniform int yuvFormat;uniform int isModel;uniform sampler2D uTextureSampler0;uniform sampler2D uTextureSampler1;uniform sampler2D uTextureSampler2;uniform sampler2D uTextureSampler3;uniform mat4 colorMat;void main(){vec3 yuvData;float x1 = vTextureCoord.x;float y1 = vTextureCoord.y;vec2 distortCoord = vec2(x1,y1);bool isEmpty = false;if (range != 0.0){    float real_range;    if (angle == 1 || angle == 3) {        if (distortType == 0)        {            real_range = 4.0 * range * (x1 - 0.5) * (x1 - 0.5);        }        else        {            real_range = 4.0 * range * x1 * (1.0 - x1);        }        if ((distortOri == distortType))        {            if (y1 > 1.0 - real_range - stride_y + 2.0 * stride_y * real_range || y1 < stride_y)            {                isEmpty = true;            }            else            {                float y2 = (y1 - stride_y * real_range) / (1.0 - real_range);                distortCoord = vec2(x1,y2);            }        }        else        {            if (y1 <  real_range + stride_y - 2.0 * stride_y * real_range || y1 > 1.0 - stride_y)            {                isEmpty = true;            }            else            {                float y2 = (y1 - real_range + stride_y * real_range) / (1.0 - real_range);                distortCoord = vec2(x1,y2);            }        }     }  else {        if (distortType == 0)        {            real_range = 4.0 * range * (y1 - 0.5) * (y1 - 0.5);        }        else        {            real_range = 4.0 * range * y1 * (1.0 - y1);        }        if ((distortOri == distortType))        {            if (x1 > 1.0 - real_range - stride_x + 2.0 * stride_x * real_range || x1 < stride_x)            {                isEmpty = true;            }            else            {                float x2 = (x1 - stride_x * real_range) / (1.0 - real_range);                distortCoord = vec2(x2,y1);            }        }        else        {            if (x1 <  real_range + stride_x - 2.0 * stride_x * real_range || x1 > 1.0 - stride_x)            {                isEmpty = true;            }            else            {                float x2 = (x1 - real_range + stride_x * real_range) / (1.0 - real_range);                distortCoord = vec2(x2,y1);            }        }  }} if (isEmpty){    gl_FragColor = vec4(0,0,0,0);}else{  yuvData.x = texture2D(uTextureSampler0, distortCoord).x;    if(yuvFormat==1||yuvFormat==2){      vec2 uv = texture2D(uTextureSampler1, distortCoord).ra;      yuvData.y = uv.x;      yuvData.z = uv.y;}else if(yuvFormat==3){      vec2 uv = texture2D(uTextureSampler1, distortCoord).ra;      yuvData.z = uv.x;      yuvData.y = uv.y;}else{     yuvData.y = texture2D(uTextureSampler1, distortCoord).x;      yuvData.z = texture2D(uTextureSampler2, distortCoord).x;}  vec4 rgbData =  colorMat * vec4(yuvData,1.0);gl_FragColor = vec4 (rgbData.xyz, 1.0) * uAlpha;}if(isModel==1){        gl_FragColor.a=texture2D(uTextureSampler3, vTextureCoordModel).a;}}";
    }
}
